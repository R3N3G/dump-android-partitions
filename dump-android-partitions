#!/bin/bash
# execute it on PC
# desirably, before first boot
#set -x
verbose=false
dryrun=false
excludefile='dump.exclude'
DEFAULT_PATHES=(
  '/dev/block/*/*/by-name'
  '/dev/block/*/*/*/by-name'
  '/dev/block/*/*/by-num'
  '/dev/block/*/*/*/by-num'
)

progname=`basename $0`
usage="$progname [-hvn] [-p glob] [-x exclude]
  -h
    print this message and exit
  -v
    verbosely echoing
  -n
    dry-run with verbose
  -p GLOB
    A shell glob pattern to search directories that includes partition names as file(node) names.
    example: $progname -p /dev/block/platform/*/msm_sdcc.1/by-name
    To use multiple globs, you can repeat -p options.
    default globs: ${DEFAULT_PATHES[@]}
  -x EXCLUDE
    A file includes partition names to be excluded from dumping
    default: $excludefile
  -s SERIAL
    use device with given serial number (overrides \$ANDROID_SERIAL), same as adb command.
"

globs=()
while true; do
  case "$1" in
  -p) globs+=("$2"); shift 2;;
  -x) excludefile="$2"; shift 2;;
  -s) serial="$2"; shift 2;;
  -h) echo "$usage"; exit 0;;
  -v) verbose=true; shift;;
  -n) dryrun=true; verbose=true; shift;;
  -*) shift;;
  *) break;;
  esac
done
test ${#globs[@]} -eq 0 && globs=${DEFAULT_PATHES[@]}

## functions
##

_adb() {
  adb ${serial:+-s $serial} "$@"
}

number_of_remote_devices() {
  adb devices | grep -v -e '^List of devices attached$' -e '^$' | grep "^$serial	" | wc -l
}

adbx() {
  _adb "$@" | sed -b 's/\r$//'
}

adb_echo_result() {
  adbx shell $sucmd "$@" ">/dev/null" "2>/dev/null" ";" "echo" "\$?"
}

adb_return_result() {
  rc="`adb_echo_result \"\$@\"`"
  return $rc
}

remote_cmd_not_exist() {
  rc="`adb_echo_result \"\$@\"`"
  test "$rc" = "127"
}

globmatch() {
  case "$1" in
  $2) true;;
  *) false;;
  esac
}

remote_adb_is_rooted() {
  globmatch "`adbx shell id`" 'uid=0\(*'
}

remote_su_not_exist() {
  remote_cmd_not_exist su -c echo
}

get_partitions_list_dir() {
  declare -n partListGlobs=$1
  partListDir=
  for glob in ${partListGlobs[@]}; do
    partListDirs=`adbx shell $sucmd echo "$glob"`
    partListDirs_len=`echo "$partListDirs" | wc -w`
    $verbose && echo "partitions (by name) list: $partListDirs">&2
    if [ $partListDirs_len -eq 1 ] && adb_return_result test -d "$partListDirs"; then
      partListDir="$partListDirs"
      break
    fi
  done
  if [ -z "$partListDir" ]; then
    if [ $partListDirs_len -eq 1 ]; then
      echo "There are no partitions list directory for: ${partListGlobs[@]}">&2
    else
      echo "There are multiple partitions list directories for ${partListGlobs[@]} are found as follows:">&2
      echo "  $partListDirs">&2
      echo "You can use -p option to specify single partitions list directory.">&2
    fi
    return 2
  fi
  echo "$partListDir"
}

## main
##

nrdev=`number_of_remote_devices`
if [ $nrdev -eq 0 ]; then
  echo "$0: No remote adb devices.">&2
  exit 2
elif [ $nrdev -ge 2 ]; then
  echo "$0: Two or more remote adb devices exist. Please use $ANDROID_SERIAL envvar, or -s option.">&2
  exit 2
fi

if remote_cmd_not_exist id; then
  echo "$0: Unable to dump: No id command: I gave up.">&2
  exit 2
fi
if remote_adb_is_rooted; then
  sucmd=''
elif remote_su_not_exist; then
  echo "$0: Unable to dump: There are neither rooted adbx nor su command.">&2
  exit 2
else
  sucmd='su -c'
fi

test -f "$excludefile" && {
  exclude=`sed 's/^#.*$//;s/[:space:][:space:]*#.*$//;/^$/d' "$excludefile"`
} || exclude=''


partListDir=`get_partitions_list_dir globs`
if [ $? -ne 0 ]; then exit 2; fi

parts=`adbx shell $sucmd ls "$partListDir"`
parts_len=`echo "$parts" | wc -w`
$verbose && echo "partitions: $parts"
ipart=0
for part in $parts; do
  ipart=`expr $ipart + 1`
  echo -n "($ipart/$parts_len)$part:"
  for ex in $exclude; do
    if [ "$part" = "$ex" ]; then
      echo excluded.
      continue 2
    fi
  done
  echo
  $verbose && echo "adbx shell $sucmd \"cat $partListDir/$part\" >\"$part.img\""
  $dryrun || adbx shell $sucmd "cat $partListDir/$part" >"$part.img"
done
exit 0
